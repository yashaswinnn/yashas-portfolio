{"ast":null,"code":"import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont } from \"@tsparticles/engine\";\nimport { drawEmoji } from \"./Utils.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"',\n  noPadding = 0;\nexport class EmojiDrawer {\n  constructor() {\n    this.validTypes = [\"emoji\"];\n    this._emojiShapeDict = new Map();\n  }\n  destroy() {\n    for (const [key, data] of this._emojiShapeDict) {\n      if (data instanceof ImageBitmap) {\n        data?.close();\n      }\n      this._emojiShapeDict.delete(key);\n    }\n  }\n  draw(data) {\n    const key = data.particle.emojiDataKey;\n    if (!key) {\n      return;\n    }\n    const image = this._emojiShapeDict.get(key);\n    if (!image) {\n      return;\n    }\n    drawEmoji(data, image);\n  }\n  async init(container) {\n    const options = container.actualOptions,\n      {\n        validTypes\n      } = this;\n    if (!validTypes.find(t => isInArray(t, options.particles.shape.type))) {\n      return;\n    }\n    const promises = [loadFont(defaultFont)],\n      shapeOptions = validTypes.map(t => options.particles.shape.options[t]).find(t => !!t);\n    if (shapeOptions) {\n      executeOnSingleOrMultiple(shapeOptions, shape => {\n        if (shape.font) {\n          promises.push(loadFont(shape.font));\n        }\n      });\n    }\n    await Promise.all(promises);\n  }\n  particleDestroy(particle) {\n    particle.emojiDataKey = undefined;\n  }\n  particleInit(_container, particle) {\n    const double = 2,\n      shapeData = particle.shapeData;\n    if (!shapeData?.value) {\n      return;\n    }\n    const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData);\n    if (!emoji) {\n      return;\n    }\n    const emojiOptions = typeof emoji === \"string\" ? {\n        font: shapeData.font ?? defaultFont,\n        padding: shapeData.padding ?? noPadding,\n        value: emoji\n      } : {\n        font: defaultFont,\n        padding: noPadding,\n        ...shapeData,\n        ...emoji\n      },\n      font = emojiOptions.font,\n      value = emojiOptions.value;\n    const key = `${value}_${font}`;\n    if (this._emojiShapeDict.has(key)) {\n      particle.emojiDataKey = key;\n      return;\n    }\n    const padding = emojiOptions.padding * double,\n      maxSize = getRangeMax(particle.size.value),\n      fullSize = maxSize + padding,\n      canvasSize = fullSize * double;\n    let image;\n    if (typeof OffscreenCanvas !== \"undefined\") {\n      const canvas = new OffscreenCanvas(canvasSize, canvasSize),\n        context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = `400 ${maxSize * double}px ${font}`;\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(value, fullSize, fullSize);\n      image = canvas.transferToImageBitmap();\n    } else {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = canvasSize;\n      canvas.height = canvasSize;\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = `400 ${maxSize * double}px ${font}`;\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(value, fullSize, fullSize);\n      image = canvas;\n    }\n    this._emojiShapeDict.set(key, image);\n    particle.emojiDataKey = key;\n  }\n}","map":{"version":3,"names":["executeOnSingleOrMultiple","getRangeMax","isInArray","itemFromSingleOrMultiple","loadFont","drawEmoji","defaultFont","noPadding","EmojiDrawer","constructor","validTypes","_emojiShapeDict","Map","destroy","key","data","ImageBitmap","close","delete","draw","particle","emojiDataKey","image","get","init","container","options","actualOptions","find","t","particles","shape","type","promises","shapeOptions","map","font","push","Promise","all","particleDestroy","undefined","particleInit","_container","double","shapeData","value","emoji","randomIndexData","emojiOptions","padding","has","maxSize","size","fullSize","canvasSize","OffscreenCanvas","canvas","context","getContext","textBaseline","textAlign","fillText","transferToImageBitmap","document","createElement","width","height","set"],"sources":["C:/Users/INTEL/Desktop/yashas/node_modules/@tsparticles/shape-emoji/browser/EmojiDrawer.js"],"sourcesContent":["import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nimport { drawEmoji } from \"./Utils.js\";\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"', noPadding = 0;\nexport class EmojiDrawer {\n    constructor() {\n        this.validTypes = [\"emoji\"];\n        this._emojiShapeDict = new Map();\n    }\n    destroy() {\n        for (const [key, data] of this._emojiShapeDict) {\n            if (data instanceof ImageBitmap) {\n                data?.close();\n            }\n            this._emojiShapeDict.delete(key);\n        }\n    }\n    draw(data) {\n        const key = data.particle.emojiDataKey;\n        if (!key) {\n            return;\n        }\n        const image = this._emojiShapeDict.get(key);\n        if (!image) {\n            return;\n        }\n        drawEmoji(data, image);\n    }\n    async init(container) {\n        const options = container.actualOptions, { validTypes } = this;\n        if (!validTypes.find(t => isInArray(t, options.particles.shape.type))) {\n            return;\n        }\n        const promises = [loadFont(defaultFont)], shapeOptions = validTypes\n            .map(t => options.particles.shape.options[t])\n            .find(t => !!t);\n        if (shapeOptions) {\n            executeOnSingleOrMultiple(shapeOptions, shape => {\n                if (shape.font) {\n                    promises.push(loadFont(shape.font));\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    particleDestroy(particle) {\n        particle.emojiDataKey = undefined;\n    }\n    particleInit(_container, particle) {\n        const double = 2, shapeData = particle.shapeData;\n        if (!shapeData?.value) {\n            return;\n        }\n        const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData);\n        if (!emoji) {\n            return;\n        }\n        const emojiOptions = typeof emoji === \"string\"\n            ? {\n                font: shapeData.font ?? defaultFont,\n                padding: shapeData.padding ?? noPadding,\n                value: emoji,\n            }\n            : {\n                font: defaultFont,\n                padding: noPadding,\n                ...shapeData,\n                ...emoji,\n            }, font = emojiOptions.font, value = emojiOptions.value;\n        const key = `${value}_${font}`;\n        if (this._emojiShapeDict.has(key)) {\n            particle.emojiDataKey = key;\n            return;\n        }\n        const padding = emojiOptions.padding * double, maxSize = getRangeMax(particle.size.value), fullSize = maxSize + padding, canvasSize = fullSize * double;\n        let image;\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(value, fullSize, fullSize);\n            image = canvas.transferToImageBitmap();\n        }\n        else {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = canvasSize;\n            canvas.height = canvasSize;\n            const context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${maxSize * double}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(value, fullSize, fullSize);\n            image = canvas;\n        }\n        this._emojiShapeDict.set(key, image);\n        particle.emojiDataKey = key;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}